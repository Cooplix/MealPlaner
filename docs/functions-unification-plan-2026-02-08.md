# План об'єднання функцій додатку MealPlaner

Дата: 2026-02-08

## 1. Мета
Об'єднати наявні модулі в один наскрізний процес:
`Страви + Календар` -> `Список покупок` -> `Покупки` -> `Запаси` -> `Калорійність + Витрати + Собівартість`.

Результат має бути таким, щоб користувач працював з одним джерелом даних по інгредієнтах і бачив узгоджені дані у всіх вкладках.

## 2. Поточний стан (факт по коду)

### 2.1 Що вже є
- Модулі у фронтенді: `calendar`, `dishes`, `shopping`, `purchases`, `ingredients`, `calories`, `spending`, `dishCosts`, `inventory`.
- Бекенд ендпоінти покривають кожен модуль окремо:
  - `/api/dishes`, `/api/plans`, `/api/shopping-list`
  - `/api/ingredients`, `/api/calories`, `/api/purchases`
  - `/api/inventory`, `/api/pet-inventory`
- Базова бізнес-логіка є:
  - `ShoppingService` агрегує список покупок з планів і страв.
  - `DishService` рахує калорії страв на основі таблиці калорій.
  - `SpendingPage` і `DishCostsPage` рахують аналітику по покупках.

### 2.2 Ключові розриви між функціями
1. Немає єдиного ключа інгредієнта у всіх сутностях.
- `purchases` працює через `ingredientKey`.
- `dishes` і `inventory` працюють переважно через `name + unit` (текст).

2. Немає наскрізного зв'язку між покупками і запасами.
- Створення покупки не оновлює `inventory_items`.
- `shopping-list` не віднімає наявні запаси з потреби.

3. Логіка "що потрібно купити" розірвана.
- Є список покупок з плану страв.
- Є мін/макс у запасах.
- Немає єдиного обчислення дефіциту, яке об'єднує ці два джерела.

4. Модулі з різною моделлю багатокористувацькості.
- `inventory` має `user_id` і user-scoped доступ.
- `dishes`, `plans`, `ingredients`, `calories`, `purchases` зараз не user-scoped.

5. Частина критичних обчислень живе тільки у фронтенді.
- Аналітика витрат/калорій/собівартості обчислюється у `front/src/utils/statistics.ts`.
- Бекенд не має узгодженого агрегованого API для цих показників.

## 3. Цільова модель об'єднання

### 3.1 Єдиний доменний ланцюжок
1. Користувач планує меню (`plans`, `dishes`).
2. Система рахує потребу інгредієнтів по плану.
3. Система віднімає доступні запаси.
4. Формується "купити" (дефіцит) + пріоритет (термінові/критичні).
5. Під час створення покупки можна одразу додавати в запаси.
6. Після споживання/приготування запаси зменшуються.
7. Витрати, собівартість страв і калорійність перераховуються на спільних даних.

### 3.2 Канонічні сутності
- `IngredientCatalog` (база): ключ, назва, переклади, базова одиниця, категорія.
- `DishIngredient`: обов'язково `ingredientKey`, додатково `qty`, `unit`.
- `InventoryItem`: прив'язка до `ingredientKey` (для сумісності поки дозволити `name` fallback).
- `Purchase`: прив'язка до `ingredientKey`, опційно прапорець `applyToInventory`.

## 4. Покроковий план реалізації

### Крок 1. Уніфікувати ідентифікацію інгредієнтів
Ціль:
- У всіх нових записах використовувати `ingredientKey` як головний зв'язок.

Роботи:
- Додати `ingredientKey` в моделі/DTO для `dishes` інгредієнтів і `inventory_items`.
- На фронті в формах страв і запасів зберігати вибір через довідник інгредієнтів.
- Залишити тимчасовий fallback на `name+unit` для старих записів.

DoD:
- Нові страви і нові записи запасів мають `ingredientKey`.
- Старі дані читаються без падінь.

### Крок 2. Вирівняти multi-user модель
Ціль:
- Всі доменні записи мають належати конкретному користувачу.

Роботи:
- Додати `user_id` в `dishes`, `plans`, `ingredients`, `calories`, `purchases`.
- Оновити репозиторії та сервіси на `findByUserId...`.
- Міграція існуючих даних на поточного користувача/власника.

DoD:
- Користувач бачить тільки свої дані у всіх модулях.

### Крок 3. Shopping List v2 (план - запаси = дефіцит)
Ціль:
- Список покупок має враховувати залишки на складі.

Роботи:
- У `ShoppingService` додати агрегацію запасів по `ingredientKey`.
- Рахувати:
  - `requiredQty` (з плану),
  - `inStockQty` (із запасів),
  - `toBuyQty = max(required - inStock, 0)`.
- Віддати розширений DTO для фронту.

DoD:
- У вкладці покупок видно саме дефіцит, а не просто суму з рецептів.

### Крок 4. Покупки -> автооновлення запасів
Ціль:
- Опційно автоматично поповнювати запаси при внесенні покупки.

Роботи:
- Додати в `POST /api/purchases` параметр `applyToInventory`.
- Якщо `true`: upsert в `inventory_items` по `ingredientKey + location(default)`.
- Логування джерела зміни (purchase/manual/consume).

DoD:
- Покупка з `applyToInventory=true` збільшує відповідний запас.

### Крок 5. Єдина система категорій/локацій/одиниць
Ціль:
- Прибрати розсинхрон довідників між вкладками.

Роботи:
- Винести довідники в спільний конфіг/endpoint:
  - категорії,
  - локації,
  - одиниці вимірювання,
  - конверсії одиниць.
- Фронт використовує тільки ці довідники.

DoD:
- Немає "вільного" вводу без довідника там, де потрібна нормалізація.

### Крок 6. Об'єднаний екран "План закупівель"
Ціль:
- Один екран для повного циклу: потреба -> що є -> купити -> додати покупку.

Роботи:
- Нова вкладка/режим в `shopping`:
  - фільтри по періоду,
  - групування по категоріях,
  - кнопка "Створити покупку" з автопідстановкою.
- Після створення покупки автоматичний рефреш дефіциту.

DoD:
- Користувач проходить сценарій "спланував -> закупив" без переходу через 3-4 вкладки вручну.

### Крок 7. Аналітика на бекенді
Ціль:
- Перенести критичні обчислення з фронта в серверні сервіси.

Роботи:
- Додати агреговані API:
  - витрати по періоду,
  - собівартість страв,
  - поживна статистика.
- Фронт відображає готові серверні агрегати.

DoD:
- Однакова логіка і результати для всіх клієнтів.

### Крок 8. Події і пріоритезація
Ціль:
- Єдина стрічка подій для дій користувача.

Роботи:
- Об'єднати в одному endpoint події:
  - скоро закінчується термін,
  - нижче мінімуму,
  - критичні до купівлі,
  - дорогі покупки.
- Колірні пріоритети і сортування по ризику/терміновості.

DoD:
- Користувач бачить централізовані "наступні дії".

### Крок 9. Міграція даних і cutover
Ціль:
- Перехід без втрати існуючих даних.

Роботи:
- Міграційний скрипт для проставлення `ingredientKey` в історичних записах.
- Міграція user-scope полів.
- Backfill для запасів з уже існуючих покупок (опціонально, з dry-run).

DoD:
- Дані сумісні з новою моделлю, старі ендпоінти або прибрані, або закриті адаптерами.

### Крок 10. Тести і контроль якості
Ціль:
- Перевірити інтеграцію як єдиний процес, а не окремі CRUD.

Роботи:
- E2E smoke-сценарій:
  - створення інгредієнта,
  - створення страви,
  - план на тиждень,
  - генерація дефіциту,
  - покупка з автооновленням запасів,
  - перевірка витрат/собівартості/калорій.
- API integration тести для кроків 1-8.

DoD:
- Є стабільний автоматизований сценарій повного циклу.

## 5. Рекомендована послідовність запуску
1. Крок 1
2. Крок 2
3. Крок 3
4. Крок 4
5. Крок 5
6. Крок 6
7. Крок 7
8. Крок 8
9. Крок 9
10. Крок 10

## 6. Prompt-ready формат для поетапної реалізації
- `Реалізуй крок 1 з docs/functions-unification-plan-2026-02-08.md`
- `Реалізуй крок 2 з docs/functions-unification-plan-2026-02-08.md`
- ...
- `Реалізуй крок 10 з docs/functions-unification-plan-2026-02-08.md`

## 7. Критичні ризики
- Високий ризик розсинхрону під час переходу з `name+unit` на `ingredientKey`.
- Ризик "протікання" даних між користувачами до завершення кроку 2.
- Ризик некоректних чисел при конверсіях одиниць без централізованого словника.

## 8. Мінімальні метрики успіху
- 100% нових записів страв/запасів/покупок містять `ingredientKey`.
- 100% user-scoped ендпоінтів повертають тільки дані поточного користувача.
- Не менше 90% позицій shopping-list формуються з урахуванням наявних запасів.
- Повний E2E smoke-сценарій проходить стабільно.
